# setup
```{r}
# load packages
library(here)
library(tidyverse)
library(HDInterval)
library(RColorBrewer)
library(cmdstanr)
library(shinystan)
library(rstan)
library(bayesplot)

# load data and R scripts
all_dat <- read.csv(here("all_data_castaneum_crash.csv")) %>% drop_na(nt, ntp1)
source(here("scripts/support_functions.R")) # contains various user-defined functions, including "rnormt", random sampling from a truncated normal
source(here("scripts/stan_utility.R")) # for MCMC diagnostics

# plotting parameters
axis_title_size <- 24
axis_text_size <- 14
legend_title_size <- 24
legend_text_size <- 22
title_size <- 24
```

# select dataset 3
```{r}
# subset 
dat <- all_dat %>%
  filter(exp_name %in% c("corridor"),
        oviposition_days >= 7,
        nt > 0) %>% 
  mutate(crash = ifelse(nt < 60 & (nt < 20 | ntp1 > 375), 0, 1)) %>% # visually determine (with the help of the time-1 population map) crash vs no-crash replicates.
  select(nt, ntp1, oviposition_days, exp_name, chaff_presence, crash)

# For Dataset 3, a two part model-fitting setup is needed. In the first, step, we use a subset of the non-crash data to estimate the marginal posteriors of m ( = mu_alpha / beta_0), and eta_alpha. We use these posteriors as informative priors in the next step, in which the full model is fit to the remainder of the data, which includes both crash and non-crash replicates.

prop <- 0.75 # proportion of non-crash replicates that are used in the first fitting step. 

# dat1 is only replicates without crashes, but leave out a fraction "prop" of replicates without crashes
dat1 <- dat %>% 
  filter(crash == 0) %>%
  group_by(nt) %>%
  slice_sample(prop = prop)

# dat 2 has all replicates with crashes and "prop" of the replicates without crashes
dat2 <- dat %>% anti_join(dat1)

# sample sizes
dat1 %>% nrow()
dat2 %>% nrow()

# plot to make sure we sub-setted correctly
dat %>%
ggplot( aes(x = nt, y = ntp1, color = as.factor(crash))) + 
  geom_point() + 
  facet_wrap(~exp_name, scales = "free")

dat1 %>%
ggplot( aes(x = nt, y = ntp1)) + 
  geom_point() + 
  facet_wrap(~exp_name, scales = "free")

dat2 %>%
ggplot( aes(x = nt, y = ntp1, color = as.factor(crash))) + 
  geom_point() + 
  facet_wrap(~exp_name, scales = "free")
```


# fit sub-model 1 with stochasticity in egg-to-adult survival
... in order to get informative priors for mu_alpha and eta_alpha
```{r}
# define model
write('

      data {
      int <lower = 1> N; // number of total data
      vector<lower = 0>[N] nt;
      vector<lower = 0>[N] ntp1;
      vector<lower = 0>[N] ovi_period;
      real<lower = 0, upper = 1> theta_L;
      

      real <lower = 0> m_scale;
      real <lower = 0> beta0_loc;
      real <lower = 0> beta0_scale;


      real <lower = 0> eta_alpha_loc;
      real <lower = 0> eta_alpha_scale;
      }
      
      transformed data{
      real <lower = 0> epsilon_L = sqrt(theta_L*(1-theta_L));
      }
      
      parameters {
      real <lower = 0> m_raw; 
      real <lower = 0> beta0_raw; // cannibalism rate intercept (per adult, per egg)

      real <lower = 0> eta_alpha_raw; // noise in ntp1
      vector<lower = 0>[N] ft;
      vector<lower = 0>[N] zt;

      }
      
      transformed parameters {
      // declarations
      real <lower = 0> m; // parameter m = mu_alpha / beta0. The parameters mu_alpha and beta0 are highly correlated in posterior sampling, leading to divergences. The reparameterization to m prevents this
      real <lower = 0> mu_alpha; // the population-level mean oviposition rate (per adult)

      real <lower = 0> beta0; 

      real <lower = 0> eta_alpha; // noise in ntp1
      vector<lower = 0>[N] mu_zt;
      vector<lower = 0>[N] sigma_zt;
      //vector<lower = 0>[N] ft;


      // rescale non-centered parameters   
      m = m_scale * m_raw;
      beta0 = beta0_loc + beta0_scale * beta0_raw; 
      mu_alpha = m * beta0; // the oviposition rate
      eta_alpha = eta_alpha_loc + eta_alpha_scale * eta_alpha_raw;

      // true transformed params

      //ft = nt ./ 2;
      // larvae model
      vector[N] focal_exponent = ft.*ovi_period*beta0;
      
      mu_zt = mu_alpha * (1-exp(-focal_exponent)) / beta0;
      sigma_zt = eta_alpha * sqrt( (1- exp(-2 * focal_exponent)) / (2 * beta0));
      
      }
      
      model {
      // priors  
      m_raw ~ std_normal();
      beta0_raw ~ std_normal();
      eta_alpha_raw ~ std_normal();
      //ft ~ normal(0.5 * nt, 0.5 * sqrt(nt));
      
      
      // likelihood
      for(i in 1:N)
      {
        ft[i] ~ normal(0.5 * nt[i], 0.5 * sqrt(nt[i]))T[0,];
        zt[i] ~ normal(mu_zt[i], sigma_zt[i]) T[0,];
        ntp1[i] ~ normal(theta_L * zt[i], epsilon_L * sqrt(zt[i])) T[0,];
      }
      

      }
      
      ',
        
        here("models/mod1_surv_D3.stan"))

# compile
mod1_surv_D3 <- cmdstan_model(here("models/mod1_surv_D3.stan"))

# data and prior scales
dat1 %>% ggplot(aes(x = nt, y = ntp1)) + geom_point()
stan_data <- list(N = NROW(dat1),
                  nt = dat1$nt,
                  ntp1 = dat1$ntp1,
                  ovi_period = dat1$oviposition_days,
                  theta_L = 0.91,
                  m_loc = 0,
                  m_scale = 10/0.05,
                  beta0_loc = 0,
                  beta0_scale = 0.05,
                  beta1_loc = 0,
                  eta_alpha_loc = 0,
                  eta_alpha_scale = 10
                  )

# MCMC params
warmup <- 500
iter <- 500
chains <- 2
cores <- 2
thin <- 1
adapt_delta <- 0.99
max_treedepth <- 10
refresh <- 10
seed <- 20

# fit model
fit <- mod1_surv_D3$sample(data = stan_data, 
                   iter_warmup = warmup, 
                   iter_sampling = iter,
                   chains = chains,
                   parallel_chains = cores,
                   adapt_delta = adapt_delta,
                   max_treedepth = max_treedepth, 
                   refresh = refresh,
                   seed = seed)

sfit <- rstan::read_stan_csv(fit$output_files())
saveRDS(sfit, file = here("model_fits/sfit_surv_D3.rds"))
#sfit <- readRDS(file = here("model_fits/sfit_surv_D3.rds"))

# make sure pairs plot looks reasonable
pars <- c("m", "mu_alpha", "beta0", "eta_alpha")
pairs(sfit, pars = pars)

# pairs plots - one chain
par_names <- c("m", "mu_alpha", "beta0", "eta_alpha")
x <- as.array(sfit, pars = par_names)
mcmc_pairs(x, condition = pairs_condition(chains = list(1, NULL)))


```


# simulation function
```{r}
sim<- function(pars, input_dat)
{
  # prep
  nt <- input_dat[["nt"]]
  oviposition_days <- input_dat[["oviposition_days"]]
  theta_L <- pars[["theta_L"]]

  N <- length(nt)
  ft <- rnormt(N, range = c(0, Inf), m = nt/2, s = sqrt(nt)/2)

  # first simulate random z_star from truncated normal dist
  mu_zStarReal <-  pars[["gamma0"]] - pars[["gamma1"]] * nt

  z_star <- rnorm(N, mean = mu_zStarReal, sd = pars[["sigma_zStar"]])
  
  # calculate moments of eggs distribution
  beta = pars[["beta0"]] + pars[["beta1"]] * nt
  mu_zt = pars[["mu_alpha"]] * (1-exp(- ft * oviposition_days * beta)) / beta
  sigma_zt = pars[["eta_alpha"]] * sqrt( (1- exp(-2 * ft * oviposition_days * beta)) / (2 * beta))
  
  #simulate eggs
  zt <- rnormt(N, range = c(0, Inf), m = mu_zt, s = sigma_zt)
  #zt[which(zt < 0)] <- 0
  
  # simulate ntp1 asdf
  mu_theta <- theta_L  - theta_L/(1 + exp(-(6/pars[["thresh_length"]]) * (zt - z_star)))
 

  ntp1 <- rnormt(N, range = c(0, Inf), m = zt*mu_theta, s = sqrt(zt*mu_theta*(1-mu_theta)))
  #ntp1[which(ntp1 < 0)] <- 0
  
  return(ntp1)
}
```


# tune initial guesses of parameter values
```{r}
# read in the modified submodel (to have stochasticity in egg-to-adult survival) fit. The marginal posterior means can be used to help find initial conditions for the markov chains of the full model
sfit <- readRDS(file = here("model_fits/sfit_surv_D3.rds"))
pars <- c("m", "mu_alpha", "beta0", "eta_alpha")
# pairs(sfit, pars = pars)
fit_summary <- summary(sfit)
post_means <- fit_summary$summary[pars,"mean"]

# initial parameter guesses
init_pars <- tibble(
  mu_alpha = 16.5,
  beta0 = 0.012,
  beta1 = 1.5e-5,
  eta_alpha = 22,
  thresh_length = 100,
  gamma0 = 1000,
  gamma1 = 0.15,
  sigma_zStar = 100,
  epsilon_H = 0.001,
  theta_L = 0.91
)


# init_pars <- tibble(
#   mu_alpha = 16.5,
#   beta0 = 0.01,
#   beta1 = 8e-6,
#   eta_alpha = 22,
#   thresh_length = 100,
#   gamma0 = 1200,
#   gamma1 = 0.15,
#   sigma_zStar = 100,
#   epsilon_H = 0.01,
#   theta_L = 0.91
# )

# simulation / predictive-interval parameters
sim_reps <- 10000
nt_max <- dat %>% select(nt) %>% max() # the biggest initial abundance in the dataset
x <- seq(4, round(nt_max*1.1), by = 5) # unique hypothetical initial abundances to simulate from
N <- length(x) # number of unique hypothetical initial population abundances to simulate from
oviposition_days <- 7 # length of the oviposition period in days
theta_L <- 0.91 # egg-to-adult survival probability when there are few eggs
inner_perc <- 0.50 # the percentile for the inner predictive interval
outer_perc <- 0.90 # the percentile for the outer predictive interval


# pre-allocate for simulations
band_dat <- data.frame(x = x, 
                       y_m = numeric(N),
                       inner_band_lower = numeric(N), 
                       inner_band_upper = numeric(N), 
                       outer_band_lower = numeric(N), 
                       outer_band_upper = numeric(N))

for(i in 1:N)
{ 
  input_dat <- list(nt = rep(x[i], sim_reps), oviposition_days = oviposition_days) # setup input data for simulations
  y <- sim(init_pars, input_dat) # run simulations

    inner_band <- hdi(y, credMass = inner_perc)
    outer_band <- hdi(y, credMass = outer_perc)
    band_dat$y_m[i] <- mean(y)
    band_dat$inner_band_lower[i] <- inner_band[["lower"]]
    band_dat$inner_band_upper[i] <- inner_band[["upper"]]
    band_dat$outer_band_lower[i] <- outer_band[["lower"]]
    band_dat$outer_band_upper[i] <- outer_band[["upper"]]
}


band_dat[which(band_dat < 0, arr.ind =TRUE)] <- 0 # left interval endpoint can't be less than zero.

# data for drawing the mean number of eggs (approximating larvae) and the die-off threshold
line_dat <- expand_grid(x = x, init_pars) %>%
    mutate(beta = beta0 + x * beta1,
           eggs = (mu_alpha/beta)*(1-exp(-(x/2) * beta * oviposition_days))) %>%
  group_by(x) %>% 
  summarize(mean_larvae = 0.91*mean(eggs),
            mean_thresh = 0.91*mean(gamma0 - gamma1 * x)) %>% 
  pivot_longer(cols = c("mean_larvae", "mean_thresh"), names_to = "Average", values_to = "value") %>%
  mutate(Average = fct_recode(Average, "Larvae" = "mean_larvae", "Larval die-off\nthreshold" = "mean_thresh"))


# mean and sd (across the posterior) of the scaled average distance to a population crash
dist_dat <- init_pars %>%
  mutate( sd_eggs = eta_alpha/sqrt(2*beta0),
    dist = ((gamma0 + thresh_length/2) - (mu_alpha/beta0)) / sqrt(sd_eggs^2 + sigma_zStar)) %>%
  summarize(mean_dist = mean(dist),
            sd_dist = sd(dist))

# create  color palette 
reds <- brewer.pal(9, "Reds")

# make the plot
panel <- ggplot(data = band_dat) + 
  geom_ribbon(data = band_dat, mapping = aes(x = x, ymin = outer_band_lower, ymax = outer_band_upper, fill = reds[2]),  inherit.aes = FALSE) +
  geom_ribbon(data = band_dat, mapping = aes(x = x, ymin = inner_band_lower, ymax = inner_band_upper, fill = reds[3]),  inherit.aes = FALSE) + 
  geom_point(data = dat %>% filter(oviposition_days >= 7), mapping = aes(x = nt, y = ntp1)) +
 scale_fill_identity(name = 'HPrDI', guide = 'legend',labels = c(paste0(round(100*inner_perc),"%"), paste0(round(100*outer_perc),"%"))) +
  geom_line(data = line_dat, inherit.aes =FALSE, mapping = aes(x = x, y = value, group = Average, color = Average), lwd = 2) +
  scale_color_manual(name = "Average...", values=c("#9932CC", "#00AFBB")) + 
  guides(col = guide_legend(order = 2), fill = guide_legend(order = 1)) +
  coord_cartesian(ylim = c(0,1.1 * max(dat$ntp1)))  +
  scale_x_continuous(trans = 'log2', breaks = 2^seq(1,10))  +
  theme_classic() + 
  theme(plot.title = element_text(size = title_size, hjust = 0.5, margin = margin(b = -20)),
        legend.text=element_text(size=legend_text_size),
        legend.title=element_text(size=legend_title_size),
        axis.text = element_text(size = axis_text_size),
        axis.title = element_blank(),
        legend.key.size = unit(2,"line")) +
      ggtitle(as.expression(bquote(.(round(dist_dat[["mean_dist"]], digits = 1)) %+-% .(round(2*dist_dat[["sd_dist"]], digits = 1)))))
panel
```


# full stochastic model
```{r}

write('
      data {
      int <lower = 1> N; // number of total data
      vector <lower = 0>[N] nt;
      vector <lower = 0>[N] ntp1;
      vector<lower = 0>[N] ovi_period;
      
      real <lower = 0> mu_alpha_loc;
      real <lower = 0> mu_alpha_scale;
      real <lower = 0> beta0_loc;
      real <lower = 0> beta0_scale;
      real <lower = 0> beta1_loc;
      real <lower = 0> beta1_scale;
      real <lower = 0> eta_alpha_loc;
      real <lower = 0> eta_alpha_scale;
      real <lower = 0> theta_L;
      real <lower = 0> thresh_length_loc;
      real <lower = 0> thresh_length_scale;
      real <lower = 0> gamma0_loc;
      real <lower = 0> gamma0_scale;
      real <lower = 0> gamma1_scale;
      real <lower = 0> sigma_zStar_loc;
      real <lower = 0> sigma_zStar_scale;
      }
      
      transformed data{
      real <lower = 0> mu_alpha_loc2 = pow(mu_alpha_loc , 2);
      real <lower = 0> mu_alpha_scale2 = pow(mu_alpha_scale , 2);
      real <lower = 0> beta0_loc2 = pow(beta0_loc , 2);
      real <lower = 0> beta0_scale2 = pow(beta0_scale , 2);
      real <lower = 0> beta1_loc2 = pow(beta1_loc , 2);
      real <lower = 0> beta1_scale2 = pow(beta1_scale , 2);
      real <lower = 0> eta_alpha_loc2 = pow(eta_alpha_loc , 2);
      real <lower = 0> eta_alpha_scale2 = pow(eta_alpha_scale , 2);
      real <lower = 0> thresh_length_loc2 = pow(thresh_length_loc , 2);
      real <lower = 0> thresh_length_scale2 = pow(thresh_length_scale , 2);
      real <lower = 0> gamma0_loc2 = pow(gamma0_loc , 2);
      real <lower = 0> gamma0_scale2 = pow(gamma0_scale , 2);
      real <lower = 0> gamma1_scale2 = pow(gamma1_scale , 2);
      real <lower = 0> sigma_zStar_loc2 = pow(sigma_zStar_loc , 2);
      real <lower = 0> sigma_zStar_scale2 = pow(sigma_zStar_scale , 2);
      //real <lower = 0> epsilon_L = sqrt(theta_L * (1-theta_L));

      }
      
      parameters {
      real <lower = 0> mu_alpha; // the population-level mean oviposition rate (per adult)
      real <lower = 0> beta0; // cannibalism rate intercept (per adult, per egg)
      real <lower = 0> beta1; 
      real <lower = 0> eta_alpha; 
      real <lower = 0> thresh_length; 
      real <lower = 0> gamma0; 
      real <lower = 0> gamma1; 
      real <lower = 0> sigma_zStar; 
      vector<lower = 0>[N] ft;
      vector<lower = 0>[N] zt;
      vector[N] zStar_raw;
      }
      
      transformed parameters {
      // declarations
      vector<lower = 0>[N] beta; 
      vector<lower = 0>[N] mu_zStar;
      vector<lower = 0>[N] mu_zt; 
      vector<lower = 0>[N] sigma_zt;       
      vector<lower = 0>[N] mu_ntp1; 
      vector<lower = 0>[N] sigma_ntp1; 
      vector[N] focal_exponent;
      vector[N] mu_theta; // the average egg-to-adult survival probability
      vector[N] zStar; // the die-off threshold; the number of eggs required so that egg-to-adult survival is theta_L / 2
      

      beta = beta0 + nt * beta1;
      mu_zStar =  gamma0 - gamma1*nt;
      zStar = mu_zStar + sigma_zStar * zStar_raw;


      // adult-to-egg model
      focal_exponent = ft .* ovi_period .* beta;
      mu_zt = mu_alpha * (1-exp(-focal_exponent)) ./ beta;
      sigma_zt = eta_alpha * sqrt( (1- exp(-2 * focal_exponent)) ./ (2 * beta));
      
      // egg-to-adult (n(t+1)) model
      mu_theta = theta_L - (theta_L) * pow(1 + exp(-(5.8889/thresh_length)* (zt - zStar)), -1); // the average per capita egg-to-adult survival probability
      
      mu_ntp1 =  mu_theta .* zt; // average adults at generation t+1
      sigma_ntp1 = sqrt(mu_theta .* (1 - mu_theta) .* zt); // standard deviation in the number of adults at generation t+1
      }
      
      model {
      // priors  
      mu_alpha ~ normal(mu_alpha_loc, mu_alpha_scale);
      eta_alpha ~ normal(eta_alpha_loc, eta_alpha_scale);
      beta0 ~ normal(0, beta0_scale);
      beta1 ~ normal(0, beta1_scale);
      thresh_length ~ normal(0, thresh_length_scale);
      gamma0 ~ normal(gamma0_loc, gamma0_scale);
      gamma1 ~ normal(0, gamma1_scale);
      sigma_zStar ~ normal(0, sigma_zStar_scale);
      zStar_raw ~ std_normal();

      for(i in 1:N)
      {
      ft[i] ~ normal(0.5 * nt[i], 0.5 * sqrt(nt[i]))T[0,];
      zt[i] ~ normal(mu_zt[i], sigma_zt[i])T[0,];
      ntp1[i] ~ normal(mu_ntp1[i], sigma_ntp1[i])T[0,];
      }
      
      }
      ',
        
        here("models/mod1_full_D3.stan"))

# compile stan model
mod1_full_D3 <- cmdstan_model(here("models/mod1_full_D3.stan"))


# use the posterior of the submodel (parameters: m, beta0, eta_alpha) to set the priors of the full model
sfit <- readRDS(file = here("model_fits/sfit_surv_D3.rds"))
#sfit <- readRDS(file = here("model_fits/sfit1_D3.rds"))
pars <- c("mu_alpha", "eta_alpha")
# pairs(sfit, pars = pars)
# pair plot shows that the two parametes are approximately normally distributed, with zero covariance. This justifies the structure of the joint prior, which is a multivariate normal with zero cross-parameter covariation.
fit_summary <- summary(sfit)
post_means <- fit_summary$summary[pars,"mean"]
post_sds <- fit_summary$summary[pars,"sd"]


# data and prior information
stan_data <- list(N = NROW(dat2),
                  nt = dat2$nt,
                  ntp1 = dat2$ntp1,
                  ovi_period = dat2$oviposition_days,
                  theta_L = 0.91,
                  mu_alpha_loc = post_means[["mu_alpha"]],
                  mu_alpha_scale = post_sds[["mu_alpha"]],
                  beta0_loc = 0.05,
                  beta0_scale = 0.05,
                  beta1_loc = 0,
                  beta1_scale = 1.5e-5,
                  eta_alpha_loc = post_means[["eta_alpha"]],
                  eta_alpha_scale = post_sds[["eta_alpha"]],
                  thresh_length_loc = 50,
                  thresh_length_scale = 50,
                  gamma0_loc = 1000,
                  gamma0_scale = 200,
                  gamma1_scale = 0.15,
                  sigma_zStar_loc = 100,
                  sigma_zStar_scale = 100
                  )

# setup intial parameter guesses
mu_alpha_init <- init_pars[["mu_alpha"]]
beta0_init <- init_pars[["beta0"]]
beta1_init <- init_pars[["beta1"]]
eta_alpha_init <- init_pars[["eta_alpha"]]
thresh_length_init <- init_pars[["thresh_length"]]
gamma0_init <- init_pars[["gamma0"]]
gamma1_init <- init_pars[["gamma1"]]
sigma_zStar_init <- init_pars[["sigma_zStar"]]

# use intital parameter guesses to guess latent parameters (i.e., eggs, die-off thresholds)
nt <- dat2$nt
ovi_period <- dat2$oviposition_days
beta = beta0_init + nt * beta1_init
ft_init <- dat2$nt / 2
focal_exponent = ft_init * ovi_period * beta
mu_zt = mu_alpha_init * (1-exp(-focal_exponent)) / beta
zt_init <- mu_zt
mu_zStar_init <-  gamma0_init - gamma1_init*(nt)
crash_inds <- which(dat2$crash == 1) # indexes of replicates that experienced population crashes
zt_init[crash_inds] <- mu_zStar_init[crash_inds] + 100 # set initial eggs above what is expected; this (hopefully) sets the eggs above the die-off threshold and (hopefully) allows us to avoid falling into the regions of the (multi-modal) posterior where eta_alpha is very large. 


# function for MCMC initialization
initf <-function(){list(mu_alpha = mu_alpha_init,
                        beta0 = beta0_init,
                        beta1 = beta1_init,
                        eta_alpha = eta_alpha_init,
                        thresh_length = thresh_length_init,
                        gamma0 = gamma0_init,
                        gamma1 = gamma1_init,
                        sigma_zStar = sigma_zStar_init,
                        ft = ft_init,
                        zt = zt_init,
                        zStar = mu_zStar_init
                        )}


# MCMC params
warmup <- 500
iter <- 500
chains <- 8
cores <- 8
thin <- 1
adapt_delta <- 0.999
max_treedepth <- 10
refresh <- 10
seed <- 20

# fit model
fit <- mod1_full_D3$sample(data = stan_data, 
                   iter_warmup = warmup, 
                   iter_sampling = iter,
                   chains = chains,
                   parallel_chains = cores,
                   adapt_delta = adapt_delta,
                   max_treedepth = max_treedepth, 
                   refresh = refresh,
                   seed = seed,
                   init = initf)

# save the posterior and metadata
sfit <- rstan::read_stan_csv(fit$output_files())
saveRDS(sfit, file = here("model_fits/sfit_full_D3.stan"))
#sfit <- readRDS(file = here("model_fits/sfit_full_D3.stan"))
```

# compare chains
Because the model is complex (it is a doubly-nested hierarchical model!), the markov chains do not always find the region of the posterior which we are targeting. Here we probe the individual chains with respect to the distribution of log posterior density, tree depth, acceptance rate, and divergences. We also look at pair plots to make sure the marginal posteriors are biologically plausible.
```{r}
# get all parameter names
par_names <-   c("m", "beta0", "beta1", "eta_alpha", "thresh_length", "gamma0", "gamma1", "sigma_zStar", "epsilon_H", "lp__")
par_names <-   c("beta0", "beta1", "thresh_length", "gamma0", "gamma1", "sigma_zStar", "lp__")
# get all draws
x <- as.array(sfit, pars = par_names)

# look at logged posterior probabilities
temp <- list()
for(i in 1:dim(x)[2])
{
  temp[[i]] <- bind_cols(x[,i,], chain = i) 
}
df <- reduce(temp, bind_rows)
df %>% 
  rename(lp = "lp__") %>%
  mutate(chain = as.factor(chain)) %>%
  ggplot(aes(x = lp, group = chain, color = chain)) + 
  geom_density() + 
  facet_wrap(~ chain, scales = "free")


# get diagnostic stats
np <- nuts_params(sfit)

# get rid of trailing underscores in parameter names
np2 <- np %>%
  mutate(Parameter = fct_relabel(Parameter, ~ str_replace(.x, pattern = "__", replacement = "")))
np2$Parameter %>% unique() # look at stats

# compare divergences across chains
np2 %>% 
  filter(Parameter == "divergent") %>%
  group_by(Chain) %>%
  summarize(perc_div = sum(Value)/n())
  
# compare treedepth across chains
np2 %>% 
  filter(Parameter == "treedepth") %>%
  group_by(Chain) %>%
  summarize(mean_depth = mean(Value),
            sd_depth = sd(Value))

# compare accept_stat across chains
np2 %>% 
  filter(Parameter == "accept_stat") %>%
  group_by(Chain) %>%
  summarize(mean_accept = mean(Value),
            sd_accept = sd(Value))


# pairs plots - explore which chains give plausible-looking posteriors
par_names <- c("beta0", "beta1", "eta_alpha")
par_names <- c("mu_alpha", "eta_alpha")
par_names <- c("sigma_zStar", "thresh_length", "gamma0", "gamma1")
x <- as.array(sfit, pars = par_names)
mcmc_pairs(x, condition = pairs_condition(chains = list(1:8, NULL)))

# select the best chain(s)
best_chain <- 5


```


# posterior contraction: look at prior influence
```{r}
# the scales of priors 
prior_scales <- list(
                  beta0 = stan_data[["beta0_scale"]],
                  beta1 = stan_data[["beta1_scale"]],
                  thresh_length = stan_data[["thresh_length_scale"]],
                  gamma0 = stan_data[["gamma0_scale"]],
                  gamma1 = stan_data[["gamma1_scale"]],
                  sigma_zStar = stan_data[["sigma_zStar_scale"]]                  )

# function for the posterior contraction
posterior_contraction <- function(prior_var, post_var)
{
  1 - post_var/prior_var
}

# names of all parameters whose posterior contractions we will be evaluating
par_names <-   c("beta0", "beta1", "thresh_length", "gamma0", "gamma1", "sigma_zStar")

ld <- map(.x = best_chain,  ~ as_tibble(as.array(sfit, pars = par_names)[,.x,])) %>%
  reduce(.f = bind_rows) 
for(i in 1:length(par_names))
{
  post_var <- var(ld[,par_names[i]], na.rm = TRUE)
  prior_var <- prior_scales[[par_names[i]]]^2
  cat(par_names[i], "contraction is", posterior_contraction(prior_var, post_var),"\n")
}


```


# plot simulated data
```{r}
# simulation / predictive-interval parameters
sim_reps <- 5000
nt_max <- dat %>% select(nt) %>% max() # the biggest initial abundance in the dataset
x <- seq(3, round(nt_max*1.1), by = 5) # unique hypothetical initial abundances to simulate from
N <- length(x) # number of unique hypothetical initial population abundances to simulate from
oviposition_days <- 7 # length of the oviposition period in days
theta_L <- 0.91 # egg-to-adult survival probability when there are few eggs
inner_perc <- 0.50 # the percentile for the inner predictive interval
outer_perc <- 0.90 # the percentile for the outer predictive interval

# get a draw x parameter matrix of posterior samples
par_names <- c("mu_alpha", "eta_alpha", "beta0", "beta1", "thresh_length", "gamma0", "gamma1", "sigma_zStar") # parameter names

pars <- map(.x = best_chain,  ~ as_tibble(as.array(sfit, pars = par_names)[,.x,])) %>%
  reduce(.f = bind_rows) %>% 
  slice_sample(n = sim_reps, replace = T) %>%
  mutate(theta_L = 0.91)

# pre-allocate for simulations
band_dat <- data.frame(x = x, 
                       y_m = numeric(N),
                       inner_band_lower = numeric(N), 
                       inner_band_upper = numeric(N), 
                       outer_band_lower = numeric(N), 
                       outer_band_upper = numeric(N))

for(i in 1:N)
{ 
  input_dat <- list(nt = rep(x[i], sim_reps), oviposition_days = oviposition_days) # setup input data for simulations
  y <- sim(pars, input_dat) # run simulations

    inner_band <- hdi(y, credMass = inner_perc)
    outer_band <- hdi(y, credMass = outer_perc)
    band_dat$y_m[i] <- mean(y)
    band_dat$inner_band_lower[i] <- inner_band[["lower"]]
    band_dat$inner_band_upper[i] <- inner_band[["upper"]]
    band_dat$outer_band_lower[i] <- outer_band[["lower"]]
    band_dat$outer_band_upper[i] <- outer_band[["upper"]]
}


band_dat[which(band_dat < 0, arr.ind =TRUE)] <- 0 # left interval endpoint can't be less than zero.

# data for drawing the mean number of eggs (approximating larvae) and the die-off threshold
line_dat <- expand_grid(x = x, pars) %>%
    mutate(beta = beta0 + x * beta1,
           eggs = (mu_alpha/beta)*(1-exp(-(x/2) * beta * oviposition_days))) %>%
  group_by(x) %>% 
  summarize(mean_larvae = 0.91*mean(eggs),
            mean_thresh = 0.91*mean(gamma0 - gamma1 * x)) %>% 
  pivot_longer(cols = c("mean_larvae", "mean_thresh"), names_to = "Average", values_to = "value") %>%
  mutate(Average = fct_recode(Average, "Larvae" = "mean_larvae", "Larval die-off\nthreshold" = "mean_thresh"))

# mean and sd (across the posterior) of the scaled average distance to a population crash
dist_dat <- pars %>%
  mutate( sd_eggs = eta_alpha/sqrt(2*beta0),
    dist = ((gamma0 + thresh_length/2) - (mu_alpha/beta0)) / sqrt(sd_eggs^2 + sigma_zStar)) %>%
  summarize(mean_dist = mean(dist),
            sd_dist = sd(dist))

# create  color palette 
reds <- brewer.pal(9, "Reds")

# make the plot
panel <- ggplot(data = band_dat) + 
  geom_ribbon(data = band_dat, mapping = aes(x = x, ymin = outer_band_lower, ymax = outer_band_upper, fill = reds[2]),  inherit.aes = FALSE) +
  geom_ribbon(data = band_dat, mapping = aes(x = x, ymin = inner_band_lower, ymax = inner_band_upper, fill = reds[3]),  inherit.aes = FALSE) + 
  geom_point(data = dat %>% filter(oviposition_days >= 7), mapping = aes(x = nt, y = ntp1)) +
 scale_fill_identity(name = 'HPrDI', guide = 'legend',labels = c(paste0(round(100*inner_perc),"%"), paste0(round(100*outer_perc),"%"))) +
  geom_line(data = line_dat, inherit.aes =FALSE, mapping = aes(x = x, y = value, group = Average, color = Average), lwd = 2) +
  scale_color_manual(name = "Average...", values=c("#9932CC", "#00AFBB")) + 
  guides(col = guide_legend(order = 2), fill = guide_legend(order = 1)) +
  coord_cartesian(ylim = c(0,1250), xlim = c(3,1024))  +
  scale_x_continuous(trans = 'log2', breaks = 2^seq(1,10))  +
  theme_classic() + 
  theme(plot.title = element_text(size = title_size, hjust = 0.5, margin = margin(b = -20)),
        legend.text=element_text(size=legend_text_size),
        legend.title=element_text(size=legend_title_size),
        axis.text = element_text(size = axis_text_size),
        axis.title = element_blank(),
        legend.key.size = unit(2,"line")) +
      ggtitle(as.expression(bquote(.(round(dist_dat[["mean_dist"]], digits = 1)) %+-% .(round(2*dist_dat[["sd_dist"]], digits = 1)))))
panel

saveRDS(panel, file = here("figures/fig2_panelC.rds"))
```